# Test Results


**Server**: All tests were run on a single Express.js server instance (built on Node), which is single-threaded. The server implementation is stateless and so is horizontally scalable.

**Docker**:
**Hardware**: All tests were run in a simple docker container, running on a MacBook Pro 16 (M1 Max).

## Unit Tests

**Description:** Comprehensive Jest test suite covering:
- Balance calculation accuracy
- Concurrent transaction handling
- Edge cases (zero amounts, self-transfers)
- Error handling and validation
- Schema validation
- Transaction and user API endpoints
- Health checks

```bash
npm test
```

## Coverage

**Description:** Runs the same unit test suite with code coverage reporting to measure test coverage across the codebase.

```bash
npm run test:coverage
```


## k6 Tests

After hundreds of thousands of asynchronous requests, under no circumstances did the server crash, database crash, or transaction drop; nor did any transactions fail; nor was any money created or destroyed due to race conditions. 

In the condition transaction had failed unexpectedly, retry with exponential dropoff up to 10 times would have occurred. If all retries had failed, the transaction would have been logged in the failed_transactions table for the operations team and devs to triage.

### Load Ramp-up/Stress Test

**Description:** Stress test that progressively ramps up from 0 to 1000 concurrent virtual users executing random transactions between 10,000 users with $100M initial balance each. Tests system performance under heavy load with thresholds for request duration (p95 < 1000ms) and failure rate (< 10%). Includes data integrity verification in teardown.

**NOTE**: this was run locally on a single containerized server and a small containerized database, so the results are not representative of a production environment. In production, the server would be horizontally scalable to handle massively parallel requests.

**Results:**

```bash
k6 run k6-stress-test.js
```

```bash
         /\      Grafana   /â€¾â€¾/
    /\  /  \     |\  __   /  /
   /  \/    \    | |/ /  /   â€¾â€¾\
  /          \   |   (  |  (â€¾)  |
 / __________ \  |_|\_\  \_____/

     execution: local
        script: k6-stress-test.js
        output: -

     scenarios: (100.00%) 1 scenario, 1000 max VUs, 2m40s max duration (incl. graceful stop):
              * stress_test: Up to 1000 looping VUs for 2m10s over 4 stages (gracefulRampDown: 30s, gracefulStop: 30s)

INFO[0000] Setting up test data...                       source=console
INFO[0035] Created 10000 users with initial balances     source=console
INFO[0165]
Verifying data integrity...                  source=console
WARN[0167] The test has generated metrics with 100224 unique time series, which is higher than the suggested limit of 100000 and could cause high memory usage. Consider not using high-cardinality values like unique IDs as metric tags or, if you need them in the URL, use the name metric tag or URL grouping. See https://grafana.com/docs/k6/latest/using-k6/tags-and-groups/ for details.  component=metrics-engine-ingester
INFO[0176] Expected total: 100000000000000 cents         source=console
INFO[0176] Actual total: 100000000000000 cents           source=console
INFO[0176] Difference: 0 cents                           source=console


  â–ˆ THRESHOLDS

    http_req_duration
    âœ“ 'p(95)<1000' p(95)=871.03ms

    http_req_failed
    âœ“ 'rate<0.1' rate=0.00%


  â–ˆ TOTAL RESULTS

    checks_total.......: 169330  960.028203/s
    checks_succeeded...: 100.00% 169330 out of 169330
    checks_failed......: 0.00%   0 out of 169330

    âœ“ transaction created or insufficient funds

    HTTP
    http_req_duration..............: avg=264.84ms min=467Âµs    med=154.23ms max=9.25s p(90)=682.99ms p(95)=871.03ms
      { expected_response:true }...: avg=264.84ms min=467Âµs    med=154.23ms max=9.25s p(90)=682.99ms p(95)=871.03ms
    http_req_failed................: 0.00%  0 out of 199330
    http_reqs......................: 199330 1130.115288/s

    EXECUTION
    iteration_duration.............: avg=412.22ms min=101.55ms med=286.73ms max=9.35s p(90)=816.35ms p(95)=1s
    iterations.....................: 169330 960.028203/s
    vus............................: 0      min=0           max=996
    vus_max........................: 1000   min=1000        max=1000

    NETWORK
    data_received..................: 100 MB 569 kB/s
    data_sent......................: 60 MB  342 kB/s



running (2m56.4s), 0000/1000 VUs, 169330 complete and 0 interrupted iterations
stress_test âœ“ [======================================] 0000/1000 VUs  2m10s
```

### (Complex) Balance Test

**Description:** Balance read throughput test with complex setup. Creates 1000 users with 10-100 random transactions each (realistic workload), then executes 50,000 balance read requests across 100 concurrent virtual users. Tests balance endpoint performance under heavy transaction history with thresholds for request duration (p95 < 100ms), failure rate (< 1%), and throughput (> 250 reads/sec).

**NOTEs**: 
- this was run locally on a single containerized server and a small containerized database, so the results are not representative of a production environment. In production, the server would be horizontally scalable to handle massively parallel requests.
- I tested this because this is the worst-case scenario read endpoint. We could intantiate the balance calculation in a materialized view, but that would introduce a risk of attackers double-spending or spending more than their balance by exploiting the materialized view's delay in updating. To avoid this serious security risk, I chose to calculate the balance on-the-fly. I believe that after horizontal scaling, the performance would be more than sufficient. If however it wasn't, I would implement a caching layer balance fetches that would not be a security risk in the event of a data desync.

To avoid double-spend attacks leveraging data asyn, the balance is always calculated on-the-fly. In a horizontally scalable pro

```bash
k6 run k6-balance-test.js
```

```bash
         /\      Grafana   /â€¾â€¾/
    /\  /  \     |\  __   /  /
   /  \/    \    | |/ /  /   â€¾â€¾\
  /          \   |   (  |  (â€¾)  |
 / __________ \  |_|\_\  \_____/

     execution: local
        script: k6-balance-test.js
        output: -

     scenarios: (100.00%) 1 scenario, 100 max VUs, 5m30s max duration (incl. graceful stop):
              * balance_reads: 50000 iterations shared among 100 VUs (maxDuration: 5m0s, gracefulStop: 30s)

INFO[0000] Setting up test users for balance reads...    source=console
INFO[0004] Created 1000 users with balances              source=console
INFO[0004] Creating 10-100 transactions per user to build transaction history...  source=console
INFO[0023] Created transactions for 100/1000 users (6302 total transactions so far)  source=console
INFO[0039] Created transactions for 200/1000 users (11458 total transactions so far)  source=console
INFO[0056] Created transactions for 300/1000 users (17245 total transactions so far)  source=console
INFO[0074] Created transactions for 400/1000 users (22879 total transactions so far)  source=console
INFO[0092] Created transactions for 500/1000 users (28685 total transactions so far)  source=console
INFO[0109] Created transactions for 600/1000 users (34413 total transactions so far)  source=console
INFO[0128] Created transactions for 700/1000 users (40431 total transactions so far)  source=console
INFO[0147] Created transactions for 800/1000 users (45905 total transactions so far)  source=console
INFO[0167] Created transactions for 900/1000 users (52423 total transactions so far)  source=console
INFO[0184] Created transactions for 1000/1000 users (58580 total transactions so far)  source=console
INFO[0184] Setup complete: 1000 users, 58580 transactions created  source=console
INFO[0196]
ðŸ“Š Balance Read Test Complete                 source=console


  â–ˆ THRESHOLDS

    http_req_duration
    âœ“ 'p(95)<100' p(95)=27.84ms

    http_req_failed
    âœ“ 'rate<0.01' rate=0.00%

    iterations
    âœ“ 'rate>200' rate=255.183791/s


  â–ˆ TOTAL RESULTS

    checks_total.......: 100000  510.367582/s
    checks_succeeded...: 100.00% 100000 out of 100000
    checks_failed......: 0.00%   0 out of 100000

    âœ“ status is 200
    âœ“ has balance field

    HTTP
    http_req_duration..............: avg=11.99ms min=617Âµs  med=5.08ms  max=1.39s p(90)=24.04ms p(95)=27.84ms
      { expected_response:true }...: avg=11.99ms min=617Âµs  med=5.08ms  max=1.39s p(90)=24.04ms p(95)=27.84ms
    http_req_failed................: 0.00%  0 out of 110580
    http_reqs......................: 110580 564.364472/s

    EXECUTION
    iteration_duration.............: avg=23.39ms min=2.94ms med=19.67ms max=1.43s p(90)=28.49ms p(95)=33.5ms
    iterations.....................: 50000  255.183791/s
    vus............................: 100    min=0           max=100
    vus_max........................: 100    min=100         max=100

    NETWORK
    data_received..................: 47 MB  238 kB/s
    data_sent......................: 27 MB  138 kB/s

running (3m15.9s), 000/100 VUs, 50000 complete and 0 interrupted iterations
balance_reads âœ“ [======================================] 100 VUs  0m11.7s/5m0s  50000/50000 shared iters
```

### (Simple) Balance Test

**Description:** Balance read throughput test with simple setup. Creates 1000 users with exactly 1 deposit transaction each, then executes 50,000 balance read requests across 100 concurrent virtual users. Tests balance endpoint performance under minimal transaction history with thresholds for request duration (p95 < 100ms), failure rate (< 1%), and throughput (> 1000 reads/sec).

This is something of a baseline test to demonstrate the performance of a trivial database read. It can also be seen as a simulation of how performant a cached balance endpoint would perform.

```bash
k6 run k6-balance-simple-test.js
```

```bash
         /\      Grafana   /â€¾â€¾/
    /\  /  \     |\  __   /  /
   /  \/    \    | |/ /  /   â€¾â€¾\
  /          \   |   (  |  (â€¾)  |
 / __________ \  |_|\_\  \_____/

     execution: local
        script: k6-balance-simple-test.js
        output: -

     scenarios: (100.00%) 1 scenario, 100 max VUs, 5m30s max duration (incl. graceful stop):
              * balance_reads: 50000 iterations shared among 100 VUs (maxDuration: 5m0s, gracefulStop: 30s)

INFO[0000] Setting up test users for simple balance reads...  source=console
INFO[0000] Creating users...                             source=console
INFO[0000] Created 100/1000 users                        source=console
INFO[0000] Created 200/1000 users                        source=console
INFO[0000] Created 300/1000 users                        source=console
INFO[0000] Created 400/1000 users                        source=console
INFO[0000] Created 500/1000 users                        source=console
INFO[0000] Created 600/1000 users                        source=console
INFO[0000] Created 700/1000 users                        source=console
INFO[0001] Created 800/1000 users                        source=console
INFO[0001] Created 900/1000 users                        source=console
INFO[0001] Created 1000/1000 users                       source=console
INFO[0001] Created 1000 users                            source=console
INFO[0001] Creating exactly 1 deposit transaction per user...  source=console
INFO[0001] Created deposits for 100/1000 users           source=console
INFO[0001] Created deposits for 200/1000 users           source=console
INFO[0002] Created deposits for 300/1000 users           source=console
INFO[0002] Created deposits for 400/1000 users           source=console
INFO[0002] Created deposits for 500/1000 users           source=console
INFO[0002] Created deposits for 600/1000 users           source=console
INFO[0002] Created deposits for 700/1000 users           source=console
INFO[0003] Created deposits for 800/1000 users           source=console
INFO[0003] Created deposits for 900/1000 users           source=console
INFO[0003] Created deposits for 1000/1000 users          source=console
INFO[0003] Setup complete: 1000 users, 1000 transactions (1 per user)  source=console
INFO[0013]
ðŸ“Š Simple Balance Read Test Complete          source=console


  â–ˆ THRESHOLDS

    http_req_duration
    âœ“ 'p(95)<100' p(95)=24.97ms

    http_req_failed
    âœ“ 'rate<0.01' rate=0.00%

    iterations
    âœ“ 'rate>1000' rate=3626.592936/s


  â–ˆ TOTAL RESULTS

    checks_total.......: 100000  7253.185871/s
    checks_succeeded...: 100.00% 100000 out of 100000
    checks_failed......: 0.00%   0 out of 100000

    âœ“ status is 200
    âœ“ has balance field

    HTTP
    http_req_duration..............: avg=20.24ms min=593Âµs  med=17.35ms max=1.43s p(90)=22.83ms p(95)=24.97ms
      { expected_response:true }...: avg=20.24ms min=593Âµs  med=17.35ms max=1.43s p(90)=22.83ms p(95)=24.97ms
    http_req_failed................: 0.00%  0 out of 52000
    http_reqs......................: 52000  3771.656653/s

    EXECUTION
    iteration_duration.............: avg=21.11ms min=1.29ms med=17.61ms max=1.47s p(90)=22.99ms p(95)=25.14ms
    iterations.....................: 50000  3626.592936/s
    vus............................: 100    min=0          max=100
    vus_max........................: 100    min=100        max=100

    NETWORK
    data_received..................: 16 MB  1.2 MB/s
    data_sent......................: 8.1 MB 584 kB/s




running (0m13.8s), 000/100 VUs, 50000 complete and 0 interrupted iterations
balance_reads âœ“ [======================================] 100 VUs  0m10.6s/5m0s  50000/50000 shared iters
```